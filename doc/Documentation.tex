\documentclass[a4paper]{report}

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{hyperref}

\newcommand{\code}{\texttt}

\title{fs-watcher documentation}
\author{Florian Margaine}
\date{}

\begin{document}

\maketitle

\tableofcontents

\chapter{Introduction}

\code{fs-watcher} is a filesystem watcher. It allows you to react to changes
such as renaming, deleting, creating or changing a file or directory.

For example, it is common to write a \LaTeX{} document and quickly switching
to the pdf output to see how it turns out. However, to do this, you need a
program that constantly watches for file changes, so that it can run the
\LaTeX{} engine and produce the PDF every time you save the \code{.tex} file.

Another common example is writing an application in a compiled language. Or
writing CSS using a CSS-preprocessor. Or...

Many examples can take advantage of a filesystem watcher.

\chapter{The fs-watcher package}

\section{Exported symbols}

\code{fs-watcher} exports the following symbols:

\begin{itemize}
    \item The \code{*delay*} variable.
    \item The \code{watch} function.
    \item The \code{dir-watcher} class.
    \item The \code{file-watcher} class.
\end{itemize}

\section{The *delay* variable}

\code{fs-watcher} works by constantly checking for filesystem changes. These
checkings are done in an infinite loop, sleeping during a delay every time. The
\code{*delay*} variable defines this delay. The unit is seconds.

Here is the declaration of the \code{*delay*} variable:

\begin{verbatim}
(defvar *delay* 1)
\end{verbatim}

\section{The watch function}

\subsection{Description}

This is the signature of the \code{watch} function:

\begin{verbatim}
(watch pathnames listener)
\end{verbatim}

These are the types of the two arguments:

\begin{itemize}
    \item \code{pathnames}: vector.
    \item \code{listener}: function.
\end{itemize}

\code{pathnames} is a vector of pathnames to watch. It can be a file or a
folder, \code{fs-watcher} will take care of handling them correctly.

\code{listener} is a function that will be executed whenever a change is
detected. For now, it's not receiving any argument about the change that was
detected, but it might come in future versions.

\subsection{Usage examples}

Hence, here are some usage examples:

\begin{verbatim}
(fs-watcher:watch #("/some/path")
                  #'(lambda () (format t "Hello!")))

(fs-watcher:watch #("/another/path/to/file")
                  #'(lambda ()
                      (inferior-shell:run/s "make")))
\end{verbatim}

\section{The watcher class}

The \code{watcher} class is not exported, but it is an essential one: this is
the one both \code{dir-watcher} and \code{file-watcher} inherit from. So it's
worth talking about it.

\subsection{Slots}

Here is the declaration of this class:

\begin{verbatim}
(defclass watcher ()
  ((path
     :initarg :path
     :reader path)
   (mtime
     :accessor mtime)))
\end{verbatim}

A \code{watcher} object only has two slots: a \code{path} and its \code{mtime}.
The \code{mtime} is the modification time. It is the last time a file or folder
was changed.

For a folder, the \code{mtime} changes when a file or directory is added,
deleted or renamed in it. There is no recursivity involved for the \code{mtime},
so only the direct descendants are taken into account.

For a file, the \code{mtime} changes whenever its content changes.

In any case, the \code{mtime} is not affected by changing the permissions of a
file.

\subsection{Methods}

Here is the list of methods implemented by this class:

\begin{itemize}
    \item \code{check}: Checks whether a path changed. If it did, fire a change.
    \item \code{set-mtime}: Sets the \code{mtime} slot value.
    \item \code{get-mtime}: Gets the \code{mtime} slot value.
    \item \code{has-changed}: Checks whether a path changed using its mtime.
\end{itemize}

\section{The dir-watcher class}

The \code{dir-watcher} class handles watching a directory. An instance of this
class is created for each folder found.

Its particularity is that a folder watcher needs to instantiate watchers for
files and folders below it.

Also, it has to correctly handle the filesystem changes such as deleting,
renaming of creating a file. For now, this is handled by simply deleting the
current instance and recreating a new one.

\subsection{Slots}

Here is the declaration of this class:

\begin{verbatim}
(defclass dir-watcher (watcher)
  ((files
     :accessor files)))
\end{verbatim}

As you see, it inherits from \code{watcher}. It has a \code{files} slot to be
able to compare different states of a folder. (After a rename, for example.)

\subsection{Methods}

Here is the list of implemented methods:

\begin{itemize}
    \item \code{initialize-instance}: initializes the instance by setting the
        files and creating new directory watchers if necessary. It also sets
        the mtime of the directory.
    \item \code{fire-change}: deletes the current instance and recreate a new
        one, then executes the listener function.
\end{itemize}

\section{The file-watcher class}

The \code{file-watcher} class handles watching a file. An instance of this class
is created for each file found.

\subsection{Slots}

Here is the declaration of this class:

\begin{verbatim}
(defclass file-watcher (watcher) ())
\end{verbatim}

\subsection{Methods}

Here is the list of implemented methods:

\begin{itemize}
    \item \code{initialize-instance}: sets the mtime of this file.
    \item \code{fire-change}: calls the listener function.
\end{itemize}

\end{document}
